---
title: "fig_paper_09.20"
author: "Vladimir Souza"
date: "9/20/2021"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



# intro

Make all figures of the paper



# setting up

```{r}
library(dplyr)
library(ggplot2)
library(scales)
library(ComplexUpset)
library(cowplot)
library(lemon)
# library(rlang)
library(lrRNAseqBenchmark)
library(snakecase)
library(MASS)
library(viridis)


TRUTH_NAME_JURKAT <- "merged"
TRUTH_NAME_WTC11 <- "allen"
OUTPUT_DIR <- "/home/vbarbo/project_2021/paper_analysis/figures_and_results"
EXTERNAL_FIGS <- "/home/vbarbo/project_2021/paper_analysis/figures_and_results/external_figures"

# load object mt_jurkat_allMethods_notFiltered
load("/home/vbarbo/project_2021/paper_analysis/extra_files/master_tables/mt_jurkat_allMethods_notFiltered_v7.RData")
# load object mt_wtc11_allMethods_notFiltered
load("/home/vbarbo/project_2021/paper_analysis/extra_files/master_tables/mt_wtc11_allMethods_notFiltered_v7.RData")

# load object mt_jurkat_allMethods_filtered
load("/home/vbarbo/project_2021/paper_analysis/extra_files/master_tables/mt_jurkat_allMethods_filtered_v7.RData")
# load object mt_wtc11_allMethods_filtered
load("/home/vbarbo/project_2021/paper_analysis/extra_files/master_tables/mt_wtc11_allMethods_filtered_v7.RData")
```



# Fig. 1

(Fig. 1b) create the upside down pyramid showing the number of variants after each filter on the truth vcf

```{r}
dat_jurkat <- mt_jurkat_allMethods_notFiltered
dat_wtc11 <- mt_wtc11_allMethods_notFiltered


filters_to_apply <- c(
  "All variants",
  "Low density regions",
  "Exonic regions",
  "High read coverage"
)


### initiate table of varaint counts (all variants)
in_jurkat_truth <- paste0("in_", TRUTH_NAME_JURKAT)
dat <- dat_jurkat %>% 
  { paste(.[,1], .[,2], sep="-") } %>% 
  .[dat_jurkat[,in_jurkat_truth]==1] %>% 
  data.frame(pos=., Dataset="Jurkat")
in_wtc11_truth <- paste0("in_", TRUTH_NAME_WTC11)
dat <- dat_wtc11 %>% 
  { paste(.[,1], .[,2], sep="-") } %>% 
  .[dat_wtc11[,in_wtc11_truth]==1] %>% 
  data.frame(pos=., Dataset="WTC-11") %>% 
  rbind(dat, .) %>% 
  cbind(filter=filters_to_apply[1])


shortread_cover_quantiles_jurkat <- quantile(dat_jurkat$shortRead_coverage, probs=c(.05, .95))
shortread_cover_quantiles_wtc11 <- quantile(dat_wtc11$shortRead_coverage, probs=c(.05, .95))


### filter by variant density
# jurkat
variantDensity_jurkat_truth <- paste0( "variantDensity_", to_lower_camel_case(TRUTH_NAME_JURKAT) )
k <- !( dat_jurkat[,variantDensity_jurkat_truth] > 3 )
dat_jurkat <- dat_jurkat[k,]
dim(dat_jurkat)
# wtc11
variantDensity_wtc11_truth <- paste0( "variantDensity_", to_lower_camel_case(TRUTH_NAME_WTC11) )
k <- !( dat_wtc11[,variantDensity_wtc11_truth] > 3 )
dat_wtc11 <- dat_wtc11[k,]
dim(dat_wtc11)

dat1 <- dat_jurkat %>% 
  { paste(.[,1], .[,2], sep="-") } %>% 
  .[dat_jurkat[,in_jurkat_truth]==1] %>% 
  data.frame(pos=., Dataset="Jurkat")
dat1 <- dat_wtc11 %>% 
  { paste(.[,1], .[,2], sep="-") } %>% 
  .[dat_wtc11[,in_wtc11_truth]==1] %>% 
  data.frame(pos=., Dataset="WTC-11") %>% 
  rbind(dat1, .) %>% 
  cbind(filter=filters_to_apply[2])
dat <- rbind(dat, dat1)



### filter by exonic regions
# jurkat
dat_jurkat <- filter(dat_jurkat, isoSeq_coverage>0)
dim(dat_jurkat)
# wtc11
dat_wtc11 <- filter(dat_wtc11, isoSeq_coverage>0)
dim(dat_wtc11)

dat1 <- dat_jurkat %>% 
  { paste(.[,1], .[,2], sep="-") } %>% 
  .[dat_jurkat[,in_jurkat_truth]==1] %>% 
  data.frame(pos=., Dataset="Jurkat")
dat1 <- dat_wtc11 %>% 
  { paste(.[,1], .[,2], sep="-") } %>% 
  .[dat_wtc11[,in_wtc11_truth]==1] %>% 
  data.frame(pos=., Dataset="WTC-11") %>% 
  rbind(dat1, .) %>% 
  cbind(filter=filters_to_apply[3])
dat <- rbind(dat, dat1)



### filter by high read coverage
# jurkat
MIN_COVER <- 20
dat_jurkat <- filter(dat_jurkat, shortRead_coverage >= MIN_COVER &
                       shortRead_coverage <= shortread_cover_quantiles_jurkat[2])
dim(dat_jurkat)
# wtc11
dat_wtc11 <- filter(dat_wtc11, shortRead_coverage >= shortread_cover_quantiles_wtc11[1] &
                 shortRead_coverage <= shortread_cover_quantiles_wtc11[2])
dim(dat_wtc11)

dat1 <- dat_jurkat %>% 
  { paste(.[,1], .[,2], sep="-") } %>% 
  .[dat_jurkat[,in_jurkat_truth]==1] %>% 
  data.frame(pos=., Dataset="Jurkat")
dat1 <- dat_wtc11 %>% 
  { paste(.[,1], .[,2], sep="-") } %>% 
  .[dat_wtc11[,in_wtc11_truth]==1] %>% 
  data.frame(pos=., Dataset="WTC-11") %>% 
  rbind(dat1, .) %>% 
  cbind(filter=filters_to_apply[4])
dat <- rbind(dat, dat1)


dat_bk <- dat

dat$filter <- factor(dat$filter,
                     levels=rev(filters_to_apply),
                     ordered=TRUE)


### plot
p_1b <- ggplot(data=dat, aes(x=filter, fill=Dataset)) + 
  geom_bar(data=subset(dat, Dataset=="Jurkat"), aes(y=..count..*(-1))) + 
  geom_bar(data=subset(dat, Dataset=="WTC-11")) + 
  scale_y_continuous(breaks=seq(-5000000,5000000,1000000),labels=abs(seq(-5000000,5000000,1000000))) + 
  coord_flip() +
  xlab("Variants to keep") +
  ylab("Variant number") +
  theme(text = element_text(size = 20)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  theme(legend.position="bottom") +
  NULL



### add counts
num <- table(dat[,-1])
num <- as.data.frame(num)
num$x <- num$Freq
k <- num$Dataset=="Jurkat"
num$x[k] <- - num$x[k]
num$text_hjust <- ifelse(k, -0.1, 1.1)
k1 <- num$filter %in% c("Exonic regions", "High read coverage")
num$text_hjust[k1] <- ifelse(!k[k1], -0.1, 1.1)
num$Freq <- format(num$Freq, big.mark=",")
num$Freq <- gsub(" ", "", num$Freq)

p_1b <- p_1b +
  geom_text(aes(x=filter, y=x, label=Freq), num, vjust=.5, color="gray40", hjust=num$text_hjust,
            position = position_dodge(0), size=6)


fp <- file.path(OUTPUT_DIR, "pyramid_truth_filter.png")
png(fp, width=570)
p_1b
dev.off()



# ### using log scale for y axis
# dat1 <- table(dat$filter, dat$Dataset) %>% 
#   as.data.frame %>% 
#   rename("filter"="Var1", "Dataset"="Var2") %>% 
#   mutate(Freq1=ifelse(.$Dataset=="Jurkat", -.$Freq, .$Freq)) %>% 
#   mutate(logFreq=log10(Freq)) %>% 
#   mutate(logFreq1=ifelse(.$Dataset=="Jurkat", -.$logFreq, .$logFreq))
# 
# x_breaks <- seq(-5000000,5000000,1000000)
# 
# log_x_breaks <- c(-7:7)
# log_x_labels <- 10^( abs(log_x_breaks) )
# 
# p_1b <- ggplot(dat1, aes(x=logFreq1, y=filter, fill=Dataset)) +
#   geom_col() +
#   # scale_x_continuous(breaks=x_breaks,labels=abs(x_breaks)) +
#   scale_x_continuous(breaks=log_x_breaks,labels=log_x_labels) +
#   # scale_x_continuous(trans='log2') +
#   # scale_x_symmetric(labels = abs) +
#   labs(x = "Population") +
#   xlab("Variant number") +
#   ylab("Variants to keep") +
#   theme(text = element_text(size = 20)) +
#   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
#   theme(legend.position="bottom") +
#   NULL
# 
# fp <- file.path(OUTPUT_DIR, "pyramid_truth_filter_log.png")
# png(fp, width=570)
# p
# dev.off()
```

(Fig. 1d) compare the best pipelines

```{r}
dat_jurkat <- mt_jurkat_allMethods_filtered
dat_wtc11 <- mt_wtc11_allMethods_filtered


experiment_names <- c("Jurkat", "WTC-11")
output_method_names <- c("SNCR+fC+DV", "Clair3-mix", "SNCR+GATK")
dat <- calculate_precision_recall_for_multi_master_tables(
  dat_jurkat,
  dat_wtc11,
  experiment_names = experiment_names,
  method_names = c("dv_s_fc", "c3_mix", "gatk_s"),
  output_method_names = output_method_names,
  data_names = "isoSeq",
  truth_names = c(TRUTH_NAME_JURKAT, TRUTH_NAME_WTC11),
  coverage_thresholds = c(3, 15, 40, 100),
  what = "snps_indels"
)
dat$variant <- recode(dat$variant, "snps"="SNPs", "indels"="Indels")
dat$variant <- factor(dat$variant, levels=c("Indels", "SNPs"), ordered=TRUE)
dat$method <- factor(dat$method, levels=output_method_names, ordered=TRUE)
dat$experiment <- factor(dat$experiment, levels=experiment_names, ordered=TRUE)


method_cols <- hue_pal()(9)[c(1,4,7)]

### indels and spns in separated plot
p_1d <- ggplot(dat, aes(.data$recall, .data$precision, colour=.data$method)) +
  facet_grid(experiment~variant) +
  geom_point(aes(size=`coverage >= n`), alpha=.5) +
  geom_path(size=1.2, alpha=.5) +
  # theme(legend.position="bottom") +
  theme(legend.position="bottom", legend.box="vertical") +
  theme(legend.title=element_text(size=17), legend.text=element_text(size=14)) +
  coord_fixed(ratio=1, xlim=c(.5, 1.03), ylim=c(.4, 1)) +
  theme(text = element_text(size = 20)) +
  xlab("Recall") +
  ylab("Precision") +
  labs(colour="Method", size="Minimum Iso-Seq read coverage") +
  scale_x_continuous(breaks=seq(.5, 1, .1), labels=seq(.5, 1, .1)) +
  scale_color_manual(values=method_cols) +
  guides(colour = guide_legend(order=1)) +
  # theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  # expand_limits(x=c(.495, 1.005)) +
  # geom_point( aes(x=1.01, y=.6), alpha=0) +
  # geom_point( aes(x=.51, y=.6), alpha=0) +
  NULL


### add f1-score curves
calc_precision <- function(rec, f1){
  res <- (f1*rec) / (2*rec - f1)
}
f1 <- seq(.1, .9, by=.1)
xy_axix <- sapply(f1, calc_precision, rec=1)


p_1d <- p_1d +
  mapply( function(f1_i, xy_axix_i){
    stat_function(aes(colour=NULL),
                  fun=calc_precision, args=list(f1=f1_i), xlim=c(xy_axix_i, 1),
                  alpha=.5, linetype=2)
  }, f1_i=f1, xy_axix_i=xy_axix) +
  geom_text( aes(x, y, colour=NULL, label=label),
             data.frame(x=1.03, y=xy_axix, label=f1),
             show.legend=FALSE, alpha=.5 ) +
  # geom_text( aes(x, y, colour=NULL, label=label),
  #            data.frame(x=1.03, y=1, label="1.0"),
  #            show.legend=FALSE, alpha=.5 ) +
  # geom_point( aes(x, y, colour=NULL), data.frame(x=1, y=1), alpha=.3, size=.5) +
  NULL


### add more f1-score values
f1 <- .5
x <- sapply(f1, calc_precision, rec=.4) + .06
p_1d <- p_1d +
  geom_text( aes(x, y, colour=NULL, label=label),
             data.frame(x=x, y=.4, label=f1),
             show.legend=FALSE, alpha=.5, hjust=0 ) +
  NULL


fp <- file.path(OUTPUT_DIR, "bestPipelinesAndNcs_perCoverrage_indelSnpSepareted.png")
png(fp,  width=520, height=600)
p_1d
dev.off()
```

(Fig. 1e,f) upset plot to compare the best methods

```{r}
####################
###### jurkat ######
####################

dat_jurkat <- mt_jurkat_allMethods_filtered

### filter by iso-seq coverage
dat1 <- filter(dat_jurkat, isoSeq_coverage >= 30)
dim(dat1)

### filter out variant that are not in the ground truth and not called by any method
k <- select(dat1, in_dv_s_fc, in_c3_mix, in_gatk_s, all_of(in_jurkat_truth)) %>% 
  apply(1, function(x) all(x==0))
dat1 <- dat1[!k,]
dim(dat1)

### if the ground truth says the variant type is "homRef" or "hetAlt", remove it
k <- grep("variantType", names(dat1))
dat1[,k] <- lapply(dat1[,k], function(x){
  x[is.na(x)] <- "NA"
  x
})

### decide the type of the variants
variantType_jurkat_truth <- paste0("variantType_", TRUTH_NAME_JURKAT)
vartype_tbl <- select(dat1, variantType_dv_s_fc,
                      variantType_c3_mix, variantType_gatk_s,
                      all_of(variantType_jurkat_truth))

# first criterion: definition by the ground truth
# second criterion: it the ground truth doens't know the variant type, consider what
# the methods say.
truth_is_na <- vartype_tbl[,variantType_jurkat_truth] == "NA"
varTypeLevels <- c("deletion", "hetAlt", "homRef", "insertion", "NA", "snp")
k <- names(vartype_tbl) != variantType_jurkat_truth
typeCounts <- vartype_tbl[,k] %>% 
  apply(1, function(x){
    x <- factor(x, levels=varTypeLevels)
    x <- table(x)
    x
  })

vartype <- rep("NA", ncol(typeCounts))
varTypeLevels <- rownames(typeCounts)

# if all (3) methods agree with one variant type, take it
k <- apply(typeCounts, 2, function(x){
  if(any(x==3)){
    varTypeLevels[x==3]
  }else{
    NA
  }
})
k1 <- !is.na(k)
vartype[k1] <- k[k1]

# if the mahority (2) of the methods say it's a variant type, it's okay to take it
k <- apply(typeCounts, 2, function(x){
  if(any(x==2)){
    varTypeLevels[x==2]
  }else{
    NA
  }
})
k1 <- !is.na(k)
vartype[k1] <- k[k1]

# if there is only one method that call the variant, since there is nothing better to do, take it
na_indx <- varTypeLevels == "NA"
k <- apply(typeCounts, 2, function(x){
  if( x[na_indx]==2 & any(x==1) ){
    varTypeLevels[x==1]
  }else{
    NA
  }
})
k1 <- !is.na(k)
vartype[k1] <- k[k1]


k <- vartype_tbl[,variantType_jurkat_truth] == "NA"
vartype_tbl [,variantType_jurkat_truth] [k] <- vartype[k]

### don't separate by indel type
vartype_tbl[,variantType_jurkat_truth] <- recode(
  vartype_tbl[,variantType_jurkat_truth],
  "deletion"="indel", "insertion"="indel"
)
table(vartype_tbl[,variantType_jurkat_truth])


dat1$varaint_type <- vartype_tbl[,variantType_jurkat_truth]
dat1 <- filter( dat1, !(varaint_type %in% c("NA", "hetAlt", "homRef")) )
dim(dat1)
dat1 <- select(dat1, in_dv_s_fc, in_c3_mix, in_gatk_s, all_of(in_jurkat_truth), varaint_type)
dat1$varaint_type <- recode(dat1$varaint_type, "indel"="Indels", "snp"="SNPs")
dat1 <- rename(dat1, "SNCR+fC+DV"="in_dv_s_fc", "Clair3-mix"="in_c3_mix",
               "SNCR+GATK"="in_gatk_s", "Ground truth"=all_of(in_jurkat_truth),
               "Varaint Type"="varaint_type")


p_1e <- upset(
  dat1,
  names(dat1)[1:4],
  # min_size=1,
  width_ratio=0.15,
  sort_intersections=FALSE,
  sort_sets=FALSE,
  base_annotations=list(
    'Size'=intersection_size(counts=FALSE, mapping=aes(fill=`Varaint Type`))
  ),
  # intersections='all',
  set_sizes=( upset_set_size() + theme(axis.text.x=element_text(angle=90)) ),
  themes=upset_default_themes(text=element_text(size=20)),
  intersections=list(
    c("Ground truth", "SNCR+GATK", "Clair3-mix", "SNCR+fC+DV"),
    c("Ground truth", "SNCR+GATK", "Clair3-mix"),
    c("Ground truth", "SNCR+GATK", "SNCR+fC+DV"),
    c("Ground truth", "Clair3-mix", "SNCR+fC+DV"),
    c("Ground truth", "SNCR+GATK"),
    c("Ground truth", "Clair3-mix"),
    c("Ground truth", "SNCR+fC+DV"),
    c("Ground truth"),
    c("SNCR+GATK", "Clair3-mix", "SNCR+fC+DV"),
    c("SNCR+GATK", "Clair3-mix"),
    c("SNCR+GATK", "SNCR+fC+DV"),
    c("Clair3-mix", "SNCR+fC+DV"),
    c("SNCR+GATK"),
    c("Clair3-mix"),
    c("SNCR+fC+DV")
    # c('Outside of known sets')
  ),
  name="",
  wrap=TRUE
) + 
  ggtitle('Jurkat') +
  theme(plot.title = element_text(hjust = 0.5)) +
  theme(plot.title = element_text(size=30)) +
  NULL

fp <- file.path(OUTPUT_DIR, "upsetPlot_bestMethods_jurkat.png")
png(fp, width=800)
p_1e
dev.off()



####################
###### wtc11 ######
####################

dat_wtc11 <- mt_wtc11_allMethods_filtered

### filter by iso-seq coverage
dat1 <- filter(dat_wtc11, isoSeq_coverage >= 30)
dim(dat1)

### filter out variant that are not in the ground truth and not called by any method
k <- select(dat1, in_dv_s_fc, in_c3_mix, in_gatk_s, all_of(in_wtc11_truth)) %>% 
  apply(1, function(x) all(x==0))
dat1 <- dat1[!k,]
dim(dat1)

### if the ground truth says the variant type is "homRef" or "hetAlt", remove it
k <- grep("variantType", names(dat1))
dat1[,k] <- lapply(dat1[,k], function(x){
  x[is.na(x)] <- "NA"
  x
})

### decide the type of the variants
variantType_wtc11_truth <- paste0("variantType_", TRUTH_NAME_WTC11)
vartype_tbl <- select(dat1, variantType_dv_s_fc,
                      variantType_c3_mix, variantType_gatk_s,
                      all_of(variantType_wtc11_truth))

# first criterion: definition by the ground truth
# second criterion: it the ground truth doens't know the variant type, consider what
# the methods say.
truth_is_na <- vartype_tbl[,variantType_wtc11_truth] == "NA"
varTypeLevels <- c("deletion", "hetAlt", "homRef", "insertion", "NA", "snp")
k <- names(vartype_tbl) != variantType_wtc11_truth
typeCounts <- vartype_tbl[,k] %>% 
  apply(1, function(x){
    x <- factor(x, levels=varTypeLevels)
    x <- table(x)
    x
  })

vartype <- rep("NA", ncol(typeCounts))
varTypeLevels <- rownames(typeCounts)

# if all (3) methods agree with one variant type, take it
k <- apply(typeCounts, 2, function(x){
  if(any(x==3)){
    varTypeLevels[x==3]
  }else{
    NA
  }
})
k1 <- !is.na(k)
vartype[k1] <- k[k1]

# if the mahority (2) of the methods say it's a variant type, it's okay to take it
k <- apply(typeCounts, 2, function(x){
  if(any(x==2)){
    varTypeLevels[x==2]
  }else{
    NA
  }
})
k1 <- !is.na(k)
vartype[k1] <- k[k1]

# if there is only one method that call the variant, since there is nothing better to do, take it
na_indx <- varTypeLevels == "NA"
k <- apply(typeCounts, 2, function(x){
  if( x[na_indx]==2 & any(x==1) ){
    varTypeLevels[x==1]
  }else{
    NA
  }
})
k1 <- !is.na(k)
vartype[k1] <- k[k1]


k <- vartype_tbl[,variantType_wtc11_truth] == "NA"
vartype_tbl [,variantType_wtc11_truth] [k] <- vartype[k]

### don't separate by indel type
vartype_tbl[,variantType_wtc11_truth] <- recode(
  vartype_tbl[,variantType_wtc11_truth],
  "deletion"="indel", "insertion"="indel"
)
table(vartype_tbl[,variantType_wtc11_truth])


dat1$varaint_type <- vartype_tbl[,variantType_wtc11_truth]
dat1 <- filter( dat1, !(varaint_type %in% c("NA", "hetAlt", "homRef")) )
dim(dat1)
dat1 <- select(dat1, in_dv_s_fc, in_c3_mix, in_gatk_s, all_of(in_wtc11_truth), varaint_type)
dat1$varaint_type <- recode(dat1$varaint_type, "indel"="Indels", "snp"="SNPs")
dat1 <- rename(dat1, "SNCR+fC+DV"="in_dv_s_fc", "Clair3-mix"="in_c3_mix",
               "SNCR+GATK"="in_gatk_s", "Ground truth"=all_of(in_wtc11_truth),
               "Varaint Type"="varaint_type")


p_1f <- upset(
  dat1,
  names(dat1)[1:4],
  # min_size=1,
  width_ratio=0.15,
  sort_intersections=FALSE,
  sort_sets=FALSE,
  base_annotations=list(
    'Size'=intersection_size(counts=FALSE, mapping=aes(fill=`Varaint Type`))
  ),
  # intersections='all',
  set_sizes=( upset_set_size() + theme(axis.text.x=element_text(angle=90)) ),
  themes=upset_default_themes(text=element_text(size=20)),
  intersections=list(
    c("Ground truth", "SNCR+GATK", "Clair3-mix", "SNCR+fC+DV"),
    c("Ground truth", "SNCR+GATK", "Clair3-mix"),
    c("Ground truth", "SNCR+GATK", "SNCR+fC+DV"),
    c("Ground truth", "Clair3-mix", "SNCR+fC+DV"),
    c("Ground truth", "SNCR+GATK"),
    c("Ground truth", "Clair3-mix"),
    c("Ground truth", "SNCR+fC+DV"),
    c("Ground truth"),
    c("SNCR+GATK", "Clair3-mix", "SNCR+fC+DV"),
    c("SNCR+GATK", "Clair3-mix"),
    c("SNCR+GATK", "SNCR+fC+DV"),
    c("Clair3-mix", "SNCR+fC+DV"),
    c("SNCR+GATK"),
    c("Clair3-mix"),
    c("SNCR+fC+DV")
    # c('Outside of known sets')
  ),
  name="",
  wrap=TRUE
) + 
  ggtitle('WTC-11') +
  theme(plot.title = element_text(hjust = 0.5)) +
  theme(plot.title = element_text(size=30)) +
  NULL

fp <- file.path(OUTPUT_DIR, "upsetPlot_bestMethods_wtc11.png")
png(fp, width=800)
p_1f
dev.off()
```

fig_1 all together

```{r}
# load flagCorrection figure (Fig. 1a)
k <- file.path(EXTERNAL_FIGS, "fc_algorithm_be.png")
p_1a <- draw_image(k)
p_1a <- ggdraw() + p_1a

# load n-cigar schematic figure (Fig. 1c)
k <- file.path(EXTERNAL_FIGS, "schematic_n_cigar_reads_explanation_be.png")
p_1c <- draw_image(k)
p_1c <- ggdraw() + p_1c

# for some reason the upset objects didn't work with cowplot
# load the upset images instead
## jurkat upset plot
k <- file.path(OUTPUT_DIR, "upsetPlot_bestMethods_jurkat.png")
p_1e <- draw_image(k)
p_1e <- ggdraw() + p_1e
## wtc-11 upset plot
k <- file.path(OUTPUT_DIR, "upsetPlot_bestMethods_wtc11.png")
p_1f <- draw_image(k)
p_1f <- ggdraw() + p_1f


# ### give some space between figures
# save(p_1a, p_1b, p_1c, p_1d, p_1e, p_1f, file="~/keita.RData")
# load("~/keita.RData")
# 
# p_1a <- p_1a + theme(plot.margin = unit(c(3,3,3,3), "lines"))
# p_1b <- p_1b + theme(plot.margin = unit(c(3,3,3,3), "lines"))
# p_1c <- p_1c + theme(plot.margin = unit(c(3,3,3,3), "lines"))
# p_1d <- p_1d + theme(plot.margin = unit(c(3,3,3,3), "lines"))
# p_1e <- p_1e + theme(plot.margin = unit(c(3,3,3,3), "lines"))
# p_1f <- p_1f + theme(plot.margin = unit(c(3,3,3,3), "lines"))




# plots together
p_bc <- plot_grid(p_1b, NULL, p_1c,
                  labels=c("B", "", "C"), ncol=1, rel_heights=c(1, .05, .6),
                  label_size=28)
p_abc <- plot_grid(p_1a, NULL, p_bc,
                   labels=c("A"), nrow=1, rel_widths=c(1, .05, .95),
                   label_size=28)
p_ef <- plot_grid(p_1e, p_1f, 
                  labels=c("E", "F"), ncol=1, rel_heights=c(1,1),
                  label_size=28)
p_def <- plot_grid(p_1d, NULL, p_ef,
                   labels=c("D"), nrow=1, rel_widths=c(1, .05, .95),
                   label_size=28)
p_1 <- plot_grid(p_abc, p_def,
                 labels=NULL, ncol=1, rel_heights=c(1, .9),
                 label_size=28)

fp <- file.path(OUTPUT_DIR, "paper_final_figures/fig_1.png")
png(fp, width=1000, height=1300)
p_1
dev.off()
```




# Fig. 2

(Fig. 2a,b) variant calling near splice junctions, for snps (a) and for indels (b)

```{r}
# load the data to make the plots
# this load the objects: sj_proximity_snps, sj_proximity_indels
# these objects were created in the script: lrRNAseqVariantCalling/4_pre_analysis/1_splice_junction_proximity_analysis/splice_junction_proximity.R
load("/home/vbarbo/project_2021/paper_analysis/extra_files/splice_junction_proximity_analysis.Rdata")


####################
##### for snps #####
####################

sj_proximity_snps <- lapply(sj_proximity_snps, function(x){
  x$Method <- recode(x$Method, "Clair3 mix"="Clair3-mix",
                     "SNCR+FC+DeepVariant"="SNCR+fC+DeepVariant")
  x <- rename(x, "Performance measures"="Measures")
  x
})

method_cols <- hue_pal()(9)[c(2,5,8)]

p_2a <- ggplot(sj_proximity_snps$acc_sj,
            aes(x=is_near, y=Score, group=`Performance measures`,
                colour=`Performance measures`)) +
  facet_grid(experiment~Method) +
  theme(strip.text = element_text(size = 14)) +
  geom_point(size=4, alpha=.5) +
  geom_line(size=1.2, alpha=.5) +
  xlab("SNP candidates are near a splice junction") +
  theme(text = element_text(size=18)) +
  geom_text( data=sj_proximity_snps$n_text, mapping= aes(x=x, y=y, label=label), size=5 ) +
  # expand_limits( y=1.10*max(acc_both$Score) ) +
  # scale_y_continuous(breaks=seq(0,1,.1)) +
  scale_y_continuous(breaks=seq(0, 1, .25)) +
  scale_color_manual(values=method_cols) +
  guides(colour = guide_legend(override.aes = list(size = 1, shape = 11))) +
  theme(legend.position="bottom") +
  NULL

fp <- file.path(OUTPUT_DIR, "nearSJ_snps.png")
png(fp, width=570)
p_2a
dev.off()


######################
##### for indels #####
######################

sj_proximity_indels <- lapply(sj_proximity_indels, function(x){
  x$Method <- recode(x$Method, "Clair3 mix"="Clair3-mix",
                     "SNCR+FC+DeepVariant"="SNCR+fC+DeepVariant")
  x <- rename(x, "Performance measures"="Measures")
  x
})


p_2b <- ggplot(sj_proximity_indels$acc_sj,
            aes(x=is_near, y=Score, group=`Performance measures`,
                colour=`Performance measures`)) +
  facet_grid(experiment~Method) +
  theme(strip.text = element_text(size = 14)) +
  geom_point(size=4, alpha=.5) +
  geom_line(size=1.2, alpha=.5) +
  xlab("Indel candidates are near a splice junction") +
  theme(text = element_text(size=18)) +
  geom_text( data=sj_proximity_indels$n_text, mapping= aes(x=x, y=y, label=label), size=5 ) +
  # expand_limits( y=1.10*max(acc_both$Score) ) +
  # scale_y_continuous(breaks=seq(0,1,.1)) +
  scale_y_continuous(breaks=seq(0,1,.25)) +
  scale_color_manual(values=method_cols) +
  guides(colour = guide_legend(override.aes = list(size = 1, shape = 11))) +
  theme(legend.position="bottom") +
  NULL

fp <- file.path(OUTPUT_DIR, "nearSJ_indels.png")
png(fp, width=570)
p_2b
dev.off()
```

(Fig. 2c) plot for the homopolymer analysis

```{r}
# load the data to make the plot.
# this loads the object: dat_homopolymer
# it was created in the script: lrRNAseqVariantCalling/4_pre_analysis/2_homopolymer_analysis/identify_indels_within_and_outside_homopolimer_repeats.R
load("/home/vbarbo/project_2021/paper_analysis/extra_files/dat_homopolymer_analysis.RData")


dat_homopolymer <- lapply(dat_homopolymer, function(x){
  x$variant_type <- recode(x$variant_type, "deletion"="Deletion",
                           "insertion"="Insertion")
  x$method <- recode(x$method, "Clair3 mix"="Clair3-mix",
                     "SNCR+FC+DeepVariant"="SNCR+fC+DeepVariant")
  x <- rename(x, "Performance measures"="Classification")
  x
})


method_cols <- hue_pal()(9)[c(2,5,8)]

p_2c <- ggplot(dat_homopolymer$class_counts,
            aes(x=.data$homopolymer_length_intervals, y=.data$percent,
                group=.data$`Performance measures`, colour=.data$`Performance measures`)) +
  facet_grid(variant_type~method) +
  theme(strip.text = element_text(size = 14)) +
  geom_point(size=4, alpha=.5) +
  geom_line(size=1.2, alpha=.5) +
  # xlab("Variant within a homopolymer of length l") +
  xlab("Homopolymer length") +
  ylab("Score") +
  theme(text = element_text(size=20)) +
  geom_text( data=dat_homopolymer$dat_text, mapping= aes(x=x, y=y, label=label), size=5 ) +
  scale_color_manual(values=method_cols) +
  guides(colour = guide_legend(override.aes = list(size = 1, shape = 11))) +
  theme(legend.position="bottom") +
  NULL

fp <- file.path(OUTPUT_DIR, "homopolymer_analysis.png")
png(fp, width=1200, height=540)
p_2c
dev.off()
```

(Fig. 2d) plot for the ASE analysis

```{r}
# load the data to make the plot
# this loads the object: datf
# it was created in the script: ~/project_2021/projects/variantCallingFromIsoSeq/scripts_for_all_analyses_in_the_paper/ase_analysis/identify_ase_snps.R
load("~/load_later/ase_analysis/all_methods_info_to_plot.RData")

datf$method <- recode(datf$method, "Clair3 mix"="Clair3-mix",
                      "SNCR+FC+DeepVariant"="SNCR+fC+DeepVariant")

# p <- ggplot(datf, aes(x=ASE_Identification, y=Ratio, fill=Classification)) +
#   facet_grid(.~method) +
#   geom_bar(stat="identity", position=position_dodge()) +
#   geom_text(aes(label=round(Ratio,2)), vjust=1.6, color="white",
#             position = position_dodge(0.9), size=3.5)+
#   theme(text = element_text(size = 20)) +
#   ylim(0,1) +
#   xlab("Allele specific expression identification") +
#   NULL

datf <- mutate(datf, ASE_Identification=recode(datf$ASE_Identification,
                                               "Non ASE"="Non\nASE"))
datf$text_hjust <- ifelse(datf$Classification=="TP", 1.1, -0.1)

p_2d <- ggplot(datf, aes(x=ASE_Identification, y=Ratio, fill=Classification)) +
  facet_grid(method~.) +
  geom_bar(stat="identity", position=position_dodge()) +
  geom_text(aes(label=round(Ratio,2)), vjust=.5, color="gray40", hjust=datf$text_hjust,
            position = position_dodge(.9), size=6)+
  theme(text = element_text(size = 18)) +
  ylim(0,1) +
  xlab("Allele specific expression identification") +
  coord_flip() +
  theme(legend.position="bottom") +
  NULL

fp <- file.path(OUTPUT_DIR, "ase.png")
png(fp, width=300, height=600)
p_2d
dev.off()
```

fig_2 all together

```{r}
p_2c$layers
p_2c$layers[[3]] <- NULL
dat_full$dat_text$y <- dat_full$dat_text$y*1.07
p_2c <- p_2c +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  geom_text( data=dat_full$dat_text, mapping= aes(x=x, y=y, label=label),
             size=4, angle=15 ) +
  scale_y_continuous(breaks = seq(.25, 1, by = .25))

p_2a <- p_2a +
  theme(strip.text = element_text(size=12.8))

p_2b <- p_2b +
  theme(strip.text = element_text(size=12.8))

p_2a <- p_2a + theme(legend.position="none")
p_2b <- p_2b + theme(legend.position="none")

p_2d <- p_2d + theme(legend.title=element_text(size=16),
                     legend.text=element_text(size=14))

### join plots together
p_ab <- plot_grid(p_2a, NULL, p_2b,
                  labels=c("A", "", "B"), nrow=1, rel_widths=c(1, .05, 1),
                  label_size=28)
p_cd <- plot_grid(p_2c, NULL, p_2d,
                  labels=c("C", "", "D"), nrow=1, rel_widths=c(1,.05, .35),
                  label_size=28)
p_2 <- plot_grid(p_ab, NULL, p_cd,
                 labels=NULL, ncol=1, rel_heights=c(.8, .05, 1))

fp <- file.path(OUTPUT_DIR, "fig_2.png")
png(fp, width=1000, height=1000)
p_2
dev.off()
```




# Supp. figures


### (Fig. S2) compare DeepVariant pipelines, according minimum iso-seq read coverage

```{r}
dat_jurkat <- mt_jurkat_allMethods_filtered
dat_wtc11 <- mt_wtc11_allMethods_filtered


experiment_names <- c("Jurkat", "WTC-11")
output_method_names <- c("DeepVariant", "SNCR+DeepVariant", "SNCR+flagCorrection+DeepVariant")
dat <- calculate_precision_recall_for_multi_master_tables(
  dat_jurkat,
  dat_wtc11,
  experiment_names = experiment_names,
  method_names = c("dv", "dv_s", "dv_s_fc"),
  output_method_names = output_method_names,
  data_names = "isoSeq",
  truth_names = c(TRUTH_NAME_JURKAT, TRUTH_NAME_WTC11),
  coverage_thresholds = c(3, 15, 40, 100),
  what = "snps_indels"
)
dat$variant <- recode(dat$variant, "snps"="SNPs", "indels"="Indels")
dat$variant <- factor(dat$variant, levels=c("Indels", "SNPs"), ordered=TRUE)
dat$method <- factor(dat$method, levels=output_method_names, ordered=TRUE)
dat$experiment <- factor(dat$experiment, levels=experiment_names, ordered=TRUE)

method_cols <- hue_pal()(9)[c(6,2,1)]


### indels and spns in separated plot
p_s2 <- ggplot(dat, aes(.data$recall, .data$precision, colour=.data$method)) +
  facet_grid(experiment~variant) +
  geom_point(aes(size=`coverage >= n`), alpha=.5) +
  geom_path(size=1.2, alpha=.5) +
  # theme(legend.position="bottom") +
  theme(legend.position="bottom", legend.box="vertical") +
  theme(legend.title=element_text(size=17), legend.text=element_text(size=14)) +
  # coord_fixed(ratio=1, xlim=c(.2, 1.03), ylim=c(.8, 1)) +
  coord_cartesian(xlim=c(.2, 1.01), ylim=c(.78, 1)) +
  theme(text = element_text(size = 20)) +
  xlab("Recall") +
  ylab("Precision") +
  labs(colour="Pipelines", size="Minimum Iso-Seq read coverage") +
  # scale_x_continuous(breaks=seq(.5, 1, .1), labels=seq(.5, 1, .1)) +
  scale_color_manual(values=method_cols) +
  guides(colour = guide_legend(order=1)) +
  NULL


### add f1-score curves
calc_precision <- function(rec, f1){
  res <- (f1*rec) / (2*rec - f1)
}
f1 <- seq(.1, .9, by=.1)
xy_axix <- sapply(f1, calc_precision, rec=1)


p_s2 <- p_s2 +
  mapply( function(f1_i, xy_axix_i){
    stat_function(aes(colour=NULL),
                  fun=calc_precision, args=list(f1=f1_i), xlim=c(xy_axix_i, 1),
                  alpha=.5, linetype=2)
  }, f1_i=f1, xy_axix_i=xy_axix) +
  geom_text( aes(x, y, colour=NULL, label=label),
             data.frame(x=1.02, y=xy_axix, label=f1),
             show.legend=FALSE, alpha=.5 ) +
  NULL


### add more f1-score values
f1 <- seq(.3, .8, by=.1)
x <- sapply(f1, calc_precision, rec=.78) + .01
p_s2 <- p_s2 +
  geom_text( aes(x, y, colour=NULL, label=label),
             data.frame(x=x, y=.78, label=f1),
             show.legend=FALSE, alpha=.5, hjust=0 ) +
  NULL


fp <- file.path(OUTPUT_DIR, "paper_final_figures/fig_s2.png")
png(fp, width=900)
p_s2
dev.off()
```


### (Fig. S3) correlation between n-cigar-read proportion and read coverage

```{r}
dat_wtc11 <- mt_wtc11_allMethods_filtered

dat_wtc11 <- mutate(dat_wtc11, totalNumReads= isoSeq_ncr_num + isoSeq_coverage)
dat_wtc11 <- mutate(dat_wtc11, ncr_proportion= isoSeq_ncr_num / totalNumReads)

dat_wtc11 <- filter(dat_wtc11, variantDensity_dv_dvS_dvSFc_c3_c3S_c3SFc_c3Mix_gatkS_ncS <= 1)

dat_wtc11 <- filter(dat_wtc11, is_near_ss==0)


### this plot is good, but the legend is missing
# dat_wtc11 <- mutate(
#   dat_wtc11,
#   density_colour=densCols(
#     ncr_proportion,
#     isoSeq_coverage,
#     colramp= colorRampPalette( rev(rainbow(10, end=4/6)) )
#   )
# )
# p <- ggplot(dat1) +
#   geom_point(aes(ncr_proportion, isoSeq_coverage, col=density_colour),
#              alpha=.1, size=.3) +
#   scale_color_identity() +
#   # ylim(0,1000) +
#   # xlim(0,.1) +
#   NULL
# png("~/keita.png")
# p
# dev.off()

dat1 <- filter(dat_wtc11, isoSeq_coverage<2000)


get_density <- function(x, y, ...) {
  dens <- kde2d(x, y, ...)
  ix <- findInterval(x, dens$x)
  iy <- findInterval(y, dens$y)
  ii <- cbind(ix, iy)
  return(dens$z[ii])
}
dat1$Density <- get_density(x=dat1$ncr_proportion, y=dat1$isoSeq_coverage, n=100)

p_s3 <- ggplot(dat1) + 
  geom_point( aes(ncr_proportion, isoSeq_coverage, color=Density), alpha=.1, size=.3) + 
  scale_color_viridis(option = "C") +
  # ylim(0,1000) +
  xlab("Proportion of N-cigar reads") +
  ylab("Iso-Seq read coverage") +
  theme(text = element_text(size = 20)) +
  # theme(legend.position="bottom") +
  NULL

fp <- file.path(OUTPUT_DIR, "paper_final_figures/fig_s3.png")
png(fp, width=600)
p_s3
dev.off()

### another way to plot densities
# p <- ggplot( dat1, aes(ncr_proportion, isoSeq_coverage) ) +
#   stat_density_2d(
#     aes(fill = stat(level)),
#     geom = 'polygon'
#   ) +      # this is not to change
#   scale_fill_viridis_c(name = "Density") +
#   geom_point(shape = '.', alpha=.01) +
#   NULL

### third way to plot densities
# p <- ggplot(dat1, aes(x=ncr_proportion, y=isoSeq_coverage)) +
#   stat_density_2d(
#     geom = "raster",
#     aes(fill = stat(Density)),
#     contour = FALSE
#   ) +
#   scale_fill_viridis_c(name = "Density") +
#   NULL


```


### (Fig. S4) compare pipelines that use DeepVariant, per proportion of n-cigar reads

```{r}
### range of iso-seq read coverage
cover <- c(10,20)


dat_jurkat <- mt_jurkat_allMethods_filtered
# if i filter by iso-seq vanraint dentisy (all methods) the result is much better.
k <- dat_jurkat$variantDensity_dv_dvS_dvSFc_c3_c3S_c3SFc_c3Mix_gatkS_ncS <= 3
dat_jurkat <- dat_jurkat[k,]
# dat_jurkat <- filter(dat_jurkat, is_near_ss==0)
percent_n_cigar_reads <- dat_jurkat$isoSeq_ncr_num / 
  (dat_jurkat$isoSeq_ncr_num + dat_jurkat$isoSeq_coverage)
dat_jurkat <- cbind(dat_jurkat, percent_n_cigar_reads)
dat_jurkat_cover10to20 <- filter(dat_jurkat, isoSeq_coverage>=cover[1] & isoSeq_coverage<=cover[2])


dat_wtc11 <- mt_wtc11_allMethods_filtered
# if i filter by iso-seq vanraint dentisy (all methods) the result much better.
k <- dat_wtc11$variantDensity_dv_dvS_dvSFc_c3_c3S_c3SFc_c3Mix_gatkS_ncS <= 3
dat_wtc11 <- dat_wtc11[k,]
# dat_wtc11 <- filter(dat_wtc11, is_near_ss==0)
percent_n_cigar_reads <- dat_wtc11$isoSeq_ncr_num / 
  (dat_wtc11$isoSeq_ncr_num + dat_wtc11$isoSeq_coverage)
dat_wtc11 <- cbind(dat_wtc11, percent_n_cigar_reads)
dat_wtc11_cover10to20 <- filter(dat_wtc11, isoSeq_coverage>=cover[1] & isoSeq_coverage<=cover[2])



# ### distribution of n-cigar-read proportion
# # jurkat
# fp <- file.path(OUTPUT_DIR, "proportion_n_cigar_read_jurkat.png")
# png(fp)
# hist( dat_jurkat_cover10to20$percent_n_cigar_reads, br=sqrt(nrow(dat_jurkat_cover10to20)) )
# dev.off()
# # wtc-11
# fp <- file.path(OUTPUT_DIR, "proportion_n_cigar_read_wtc11.png")
# png(fp)
# hist( dat_wtc11_cover10to20$percent_n_cigar_reads, br=sqrt(nrow(dat_wtc11_cover10to20)) )
# dev.off()



# ### for equiprobable intervals of n-cigar-read percent
# k <- 3
# k <- seq(0, 1, length.out=k+1)
# k <- quantile(dat_wtc11$percent_n_cigar_reads, k)
# k <- unname(k)
# k <- round(k, 3)
# start_n_cigar_read_percent_intervals <- head(k, -1)
# end_n_cigar_read_percent_intervals <- tail(k, -1)


### arbitrary intervals
# start_n_cigar_read_percent_intervals <- c(0  , .05, .9)
# end_n_cigar_read_percent_intervals <-   c(.05, .9 , 1 )


### intervals of same ranges
n_interval  <- 3
start_n_cigar_read_percent_intervals <- head( seq(0,1, length.out=n_interval+1), -1 )
end_n_cigar_read_percent_intervals <-   tail( seq(0,1, length.out=n_interval+1), -1 )


table( findInterval(dat_wtc11_cover10to20$percent_n_cigar_reads,
                    start_n_cigar_read_percent_intervals) )

# keita[[i]] <- table( findInterval(dat_wtc11_cover10to20$percent_n_cigar_reads,
#                     start_n_cigar_read_percent_intervals) )


experiment_names <- c("jurkat", "wtc11")
method_names <- c("dv", "dv_s", "dv_s_fc")
output_method_names <- c("DeepVariant", "SNCR+DeepVariant", "SNCR+flagCorrection+DeepVariant")
# method_names <- c("c3", "c3_s", "c3_s_fc")
# output_method_names = c("Clair3", "SNCR+Clair3", "SNCR+flagCorrection+Clair3")
data_names <- "isoSeq"
truth_names <- c(TRUTH_NAME_JURKAT, TRUTH_NAME_WTC11)
what <- "snps_indels"

dat <- calculate_precision_recall_for_n_cigar_read_count_intervarls(
  dat_jurkat_cover10to20,
  dat_wtc11_cover10to20,
  experiment_names=experiment_names,
  method_names=method_names,
  output_method_names=output_method_names,
  data_names=data_names,
  truth_names=truth_names,
  start_n_cigar_read_percent_intervals=start_n_cigar_read_percent_intervals,
  end_n_cigar_read_percent_intervals=end_n_cigar_read_percent_intervals,
  what=what
)
k <- paste0("[",
            sprintf("%0.2f", start_n_cigar_read_percent_intervals),
            "-",
            sprintf("%0.2f", end_n_cigar_read_percent_intervals),
            ")")
levels(dat$`% N-cigar reads`) <- k

dat$variant <- recode(dat$variant, "snps"="SNPs", "indels"="Indels")
dat$experiment <- recode(dat$experiment, "jurkat"="Jurkat", "wtc11"="WTC-11")

method_cols <- hue_pal()(9)[c(6,2,1)]


### indels and spns in separated plot
p_s4 <- ggplot(dat, aes(.data$recall, .data$precision, colour=.data$method)) +
  facet_grid(experiment~variant) +
  geom_point(aes(size=`% N-cigar reads`), alpha=.5) +
  geom_path(size=1.2, alpha=.5) +
  # theme(legend.position="bottom") +
  theme(legend.position="bottom", legend.box="vertical") +
  # theme(legend.title=element_text(size=17), legend.text=element_text(size=14)) +
  # coord_fixed(ratio=1, xlim=c(.4, 1.01), ylim=c(.54, .91)) +
  coord_cartesian(xlim=c(0, 1.03), ylim=c(.6, 1)) +
  theme(text = element_text(size = 20)) +
  xlab("Recall") +
  ylab("Precision") +
  labs(colour="Pipelines", size="Proportion of N-cigar reads") +
  # scale_x_continuous(breaks=seq(.5, 1, .1), labels=seq(.5, 1, .1)) +
  scale_color_manual(values=method_cols) +
  guides(colour = guide_legend(order=1)) +
  NULL


### add f1-score curves
calc_precision <- function(rec, f1){
  res <- (f1*rec) / (2*rec - f1)
}
f1 <- seq(.1, .9, by=.1)
xy_axix <- sapply(f1, calc_precision, rec=1)

p_s4 <- p_s4 +
  mapply( function(f1_i, xy_axix_i){
    stat_function(aes(colour=NULL),
                  fun=calc_precision, args=list(f1=f1_i), xlim=c(xy_axix_i, 1),
                  alpha=.5, linetype=2)
  }, f1_i=f1, xy_axix_i=xy_axix) +
  geom_text( aes(x, y, colour=NULL, label=label),
             data.frame(x=1.02, y=xy_axix, label=f1),
             show.legend=FALSE, alpha=.5 ) +
  NULL


### add more f1-score values
f1 <- seq(.1, .7, by=.1)
x <- sapply(f1, calc_precision, rec=.6) + c(.005, .01, .01, .01, .015, .02, .03)
p_s4 <- p_s4 +
  geom_text( aes(x, y, colour=NULL, label=label),
             data.frame(x=x, y=.6, label=f1),
             show.legend=FALSE, alpha=.5, hjust=0 ) +
  NULL


fp <- file.path(OUTPUT_DIR, "paper_final_figures/fig_s4.png")
png(fp, width=900, height=650)
p_s4
dev.off()
```


### (Fig. S5) compare Clair3 pipelines, according minimum iso-seq read coverage

```{r}
dat_jurkat <- mt_jurkat_allMethods_filtered
dat_wtc11 <- mt_wtc11_allMethods_filtered


experiment_names <- c("Jurkat", "WTC-11")
output_method_names <- c("Clair3", "SNCR+Clair3", "SNCR+flagCorrection+Clair3")
dat <- calculate_precision_recall_for_multi_master_tables(
  dat_jurkat,
  dat_wtc11,
  experiment_names = experiment_names,
  method_names = c("c3", "c3_s", "c3_s_fc"),
  output_method_names = output_method_names,
  data_names = "isoSeq",
  truth_names = c(TRUTH_NAME_JURKAT, TRUTH_NAME_WTC11),
  coverage_thresholds = c(3, 15, 40, 100),
  what = "snps_indels"
)
dat$variant <- recode(dat$variant, "snps"="SNPs", "indels"="Indels")
dat$variant <- factor(dat$variant, levels=c("Indels", "SNPs"), ordered=TRUE)
dat$method <- factor(dat$method, levels=output_method_names, ordered=TRUE)
dat$experiment <- factor(dat$experiment, levels=experiment_names, ordered=TRUE)

method_cols <- hue_pal()(9)[c(8,3,5)]


### indels and spns in separated plot
p_s5 <- ggplot(dat, aes(.data$recall, .data$precision, colour=.data$method)) +
  facet_grid(experiment~variant) +
  geom_point(aes(size=`coverage >= n`), alpha=.5) +
  geom_path(size=1.2, alpha=.5) +
  # theme(legend.position="bottom") +
  theme(legend.position="bottom", legend.box="vertical") +
  # theme(legend.title=element_text(size=17), legend.text=element_text(size=14)) +
  coord_fixed(ratio=1, xlim=c(.4, 1.01), ylim=c(.54, .91)) +
  # coord_cartesian(xlim=c(.4, 1.03), ylim=c(.5, 1)) +
  theme(text = element_text(size = 20)) +
  xlab("Recall") +
  ylab("Precision") +
  labs(colour="Pipelines", size="Minimum Iso-Seq read coverage") +
  # scale_x_continuous(breaks=seq(.5, 1, .1), labels=seq(.5, 1, .1)) +
  scale_color_manual(values=method_cols) +
  guides(colour = guide_legend(order=1)) +
  NULL


### add f1-score curves
calc_precision <- function(rec, f1){
  res <- (f1*rec) / (2*rec - f1)
}
f1 <- seq(.1, .9, by=.1)
xy_axix <- sapply(f1, calc_precision, rec=1)

p_s5 <- p_s5 +
  mapply( function(f1_i, xy_axix_i){
    stat_function(aes(colour=NULL),
                  fun=calc_precision, args=list(f1=f1_i), xlim=c(xy_axix_i, 1),
                  alpha=.5, linetype=2)
  }, f1_i=f1, xy_axix_i=xy_axix) +
  geom_text( aes(x, y, colour=NULL, label=label),
             data.frame(x=1.02, y=xy_axix, label=f1),
             show.legend=FALSE, alpha=.5 ) +
  NULL


### add more f1-score values
f1 <- seq(.5, .6, by=.1)
x <- sapply(f1, calc_precision, rec=.54) + c(.01, .02)
p_s5 <- p_s5 +
  geom_text( aes(x, y, colour=NULL, label=label),
             data.frame(x=x, y=.54, label=f1),
             show.legend=FALSE, alpha=.5, hjust=0 ) +
  NULL


fp <- file.path(OUTPUT_DIR, "paper_final_figures/fig_s5.png")
png(fp, width=900, height=650)
p_s5
dev.off()
```


### (Fig. S6) check SNCR+NanoCaller according to minimum iso-seq read coverage

```{r}
dat_jurkat <- mt_jurkat_allMethods_filtered
dat_wtc11 <- mt_wtc11_allMethods_filtered


experiment_names <- c("Jurkat", "WTC-11")
output_method_names <- c("SNCR+NanoCaller")
dat <- calculate_precision_recall_for_multi_master_tables(
  dat_jurkat,
  dat_wtc11,
  experiment_names = experiment_names,
  method_names = c("nc_s"),
  output_method_names = output_method_names,
  data_names = "isoSeq",
  truth_names = c(TRUTH_NAME_JURKAT, TRUTH_NAME_WTC11),
  coverage_thresholds = c(3, 15, 40, 100),
  what = "snps_indels"
)
dat$variant <- recode(dat$variant, "snps"="SNPs", "indels"="Indels")
dat$variant <- factor(dat$variant, levels=c("Indels", "SNPs"), ordered=TRUE)
dat$method <- factor(dat$method, levels=output_method_names, ordered=TRUE)
dat$experiment <- factor(dat$experiment, levels=experiment_names, ordered=TRUE)

method_cols <- hue_pal()(9)[9]


### indels and spns in separated plot
p_s6 <- ggplot(dat, aes(.data$recall, .data$precision, colour=.data$method)) +
  facet_grid(experiment~variant) +
  geom_point(aes(size=`coverage >= n`), alpha=.5) +
  geom_path(size=1.2, alpha=.5) +
  # theme(legend.position="bottom") +
  theme(legend.position="bottom", legend.box="vertical") +
  theme(legend.title=element_text(size=17), legend.text=element_text(size=14)) +
  # coord_fixed(ratio=1, xlim=c(.2, 1.03), ylim=c(.8, 1)) +
  coord_cartesian(xlim=c(.04, .51), ylim=c(.78, .92)) +
  theme(text = element_text(size = 20)) +
  xlab("Recall") +
  ylab("Precision") +
  labs(colour="Pipelines", size="Minimum Iso-Seq read coverage") +
  # scale_x_continuous(breaks=seq(.5, 1, .1), labels=seq(.5, 1, .1)) +
  scale_color_manual(values=method_cols) +
  guides(colour = guide_legend(order=1)) +
  NULL


### add f1-score curves
calc_precision <- function(rec, f1){
  res <- (f1*rec) / (2*rec - f1)
}
f1 <- seq(.1, .9, by=.1)
xy_axix <- sapply(f1, calc_precision, rec=1)

p_s6 <- p_s6 +
  mapply( function(f1_i, xy_axix_i){
    stat_function(aes(colour=NULL),
                  fun=calc_precision, args=list(f1=f1_i), xlim=c(xy_axix_i, 1),
                  alpha=.5, linetype=2)
  }, f1_i=f1, xy_axix_i=xy_axix) +
  geom_text( aes(x, y, colour=NULL, label=label),
             data.frame(x=1.02, y=xy_axix, label=f1),
             show.legend=FALSE, alpha=.5 ) +
  NULL


### add more f1-score values
f1 <- seq(.1, .8, by=.1)
x <- sapply(f1, calc_precision, rec=.78) + .01
p_s6 <- p_s6 +
  geom_text( aes(x, y, colour=NULL, label=label),
             data.frame(x=x, y=.78, label=f1),
             show.legend=FALSE, alpha=.5, hjust=0 ) +
  NULL


fp <- file.path(OUTPUT_DIR, "paper_final_figures/fig_s6.png")
png(fp, width=900, height=650)
p_s6
dev.off()
```





# Tables

### (Table 1) compare the best pipelines

```{r}
dat_jurkat <- mt_jurkat_allMethods_filtered
dat_wtc11 <- mt_wtc11_allMethods_filtered


dat <- calculate_precision_recall_for_multi_master_tables(
  dat_jurkat,
  dat_wtc11,
  experiment_names = c("Jurkat", "WTC-11"),
  method_names = c("dv_s_fc", "c3_mix", "gatk_s"),
  output_method_names = c("SNCR+fC+DV", "Clair3-mix", "SNCR+GATK"),
  data_names = "isoSeq",
  truth_names = c(TRUTH_NAME_JURKAT, TRUTH_NAME_WTC11),
  coverage_thresholds = c(3, 15, 40, 100),
  what = "snps_indels"
)
dat$variant <- recode(dat$variant, "snps"="SNPs", "indels"="Indels")

dat[,1:3] <- round(dat[,1:3], 3)

names(dat) <- c("Precision", "Recall", "F1-score", "Variant_type", "Pipeline", "Mim_coverage", "Dataset")
dat <- select(dat, "Dataset", "Variant_type", "Mim_coverage", "Pipeline", "Precision", "Recall", "F1-score")
dat$Dataset <- factor(dat$Dataset, levels=c("Jurkat", "WTC-11"), ordered=TRUE)
dat$Variant_type <- factor(dat$Variant_type, levels=c("Indels", "SNPs"), ordered=TRUE)
dat$Pipeline <- factor(dat$Pipeline, levels=c("SNCR+fC+DV", "Clair3-mix", "SNCR+GATK"), ordered=TRUE)

dat <- arrange(dat, Dataset, Variant_type, Mim_coverage, Pipeline)

fp <- file.path(OUTPUT_DIR, "paper_final_figures/best_pipelines_performance_table.txt")
write.table(dat, file=fp, row.names=FALSE, quote=FALSE, sep="\t")
```

